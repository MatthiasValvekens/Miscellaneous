; some functions related to p-adic analysis
; done for learning purposes, performance is probably far from stellar
(defun integer-div (a b)
  (/ (- a (mod a b))b))
(defun egcd-iter (s k r olds oldk oldr)
  (if (= r 0)
      (list oldr olds oldk)
      (let ((q (integer-div oldr r)))
	(egcd-iter (- olds (* q s)) (- oldk (* q k)) (- oldr (* q r)) s k r))))
(defun egcd (a b)
  (egcd-iter 0 1 b 1 0 a))
(defun linear-congruence-solve (a b n)
  (destructuring-bind (d r)
      (subseq (egcd a n) 0 2)
    (if (= (mod b d) 0)
	(list (mod (/ (* r b) d) (/ n d)) (/ n d))
	nil)))

(defun incfirst (lst) (cons (+ (car lst) 1) (cdr lst)))
(defun ord (p n) 
  (if (= 0 (mod n p)) (incfirst (ord p (/ n p))) (list 0 n)))
(defun dojacobi (m n)
  (if (= m 1)
      1
      (if (= 0 (mod m 2))
	  (destructuring-bind (two-ord newm)
	      (ord 2 m)
	    (* (expt -1 (/ (* two-ord (-(* n n) 1)) 8)) (dojacobi newm n)))
	  (* (expt -1 (/ (*(- n 1) (- m 1)) 4) ) (dojacobi (mod n m) m)))))

(defun jacobi (m n)
  (if (and (> n m) (= (gcd m n) 1))
      (dojacobi m n)
      (if (zerop m)
	  0
	  nil)))
(defun eval-pol (val coeff)
  (if (= (length coeff) 0)
      0
      (+ (* (expt val (- (length coeff) 1)) (car coeff)) (eval-pol val (cdr coeff)))))
(defun differentiate-pol (coeff)
  (if (= (length coeff) 1)
      ()
      (cons (* (- (length coeff) 1) (car coeff)) (differentiate-pol (cdr coeff)))))
;refine polynomial equation solution approximations in the p-adics
(defun hensel-lift (pol approx p)
  (destructuring-bind (accuracy unit)
      (ord p (eval-pol approx pol))  ;compute quality of approximation
    (let ((h (car (linear-congruence-solve (eval-pol approx (differentiate-pol pol)) (- unit) p)))) 
      (list (+ approx (* h (expt p accuracy))) (car (ord p (eval-pol approx pol)))))))
(defun hensel-lift-chain (pol approx p desired-accuracy &optional (current-accuracy 0))
  (if (>= current-accuracy desired-accuracy)
      (list approx current-accuracy)
      (destructuring-bind (new-approx new-accuracy)
	  (hensel-lift pol approx p)
	(hensel-lift-chain pol new-approx p desired-accuracy new-accuracy))))
;expansion is (root digits)
(defun pad-expansion (old-root new-root digits)
  (if (< new-root old-root)
      (append (loop for i from 1 to (- old-root new-root) collect 0) digits)
      digits))
(defun remove-leading-zeros (n &optional (count 0))
  (if (not (zerop (car n)))
      (list n count)
      (remove-leading-zeros (cdr n) (+ count 1))))
;to do: deal with padding properly
(defun p-adic-sum (p n m &optional (carry 0)) ;assume root and length to be the same
  (if (or (not n) (not m))
      (if (> carry 0)
	  (list carry)
	  ())
      (let* ((s (+ (car n) (car m) carry))
	     (new-digit (mod s p))
	     (new-carry (/ (- s new-digit) p)))
	(cons new-digit (p-adic-sum p (cdr n) (cdr m) new-carry)))))
(defun do-p-adic-digit-mult (p dig n)
  (if (zerop dig)
      (loop for i from 1 to (length n) collect 0)
      (p-adic-sum p n (p-adic-digit-mult p (- dig 1) n))))
(defun p-adic-digit-mult (p dig n &optional (shift 0))
  (pad-expansion shift 0 (do-p-adic-digit-mult p dig n)))
(defun p-adic-mult (p n m &optional (shift 0))
  (if (or (not n) (not m))
      (loop for i from 1 to (length m) collect 0)
      (p-adic-sum p 
		  (p-adic-digit-mult p (car n) m shift) 
		  (p-adic-mult p (cdr n) m (+ shift 1))))) ;root must be the same!
(defun p-adic-cpl-helper (sb n)
  (if (not n)
      nil
      (cons (- sb (car n)) (p-adic-cpl-helper sb (cdr n)))))
(defun p-adic-cpl (p n) ;easy using p-complements
  (destructuring-bind (n-trimmed padcount)
      (remove-leading-zeros n)
    (pad-expansion padcount 0 (cons (- p (car n-trimmed)) (p-adic-cpl-helper (- p 1) (cdr n-trimmed))))))
(defun base-convert-iter (base n ord)
  (if (zerop ord)
      (list n)
      (let ((d (expt base ord)))
	(cons (integer-div n d) (base-convert-iter base (mod n d) (- ord 1))))))
(defun power-fit (p n)
  (do ((p-pow 1 (* p-pow p))
       (ord 0 (+ ord 1)))
      ((> p-pow n) (- ord 1))))
(defun base-convert (base n)
  (reverse (base-convert-iter base n (power-fit base n))))
(defun hilbert-symbol (p a b)		;integers only
  (if (and (zerop a) (zerop b)) 0
      (if (zerop a)
	  (jacobi (mod b p) p)
	  (if (zerop b)
	      (jacobi (mod a p) p)
	      (destructuring-bind (v-a u-a v-b u-b)
		  (append (ord p a) (ord p b))
		(* (expt -1 (* v-a v-b (/ (- p 1) 2))) (expt (jacobi u-a p) v-b) (expt (jacobi u-b p) v-a)))))))
