; some functions related to p-adic analysis
; done for learning purposes, performance is probably far from stellar
(defun integer-div (a b)
  (/ (- a (mod a b))b))
(defun egcd-iter (s k r olds oldk oldr)
  (if (= r 0)
      (list oldr olds oldk)
      (let ((q (integer-div oldr r)))
	(egcd-iter (- olds (* q s)) (- oldk (* q k)) (- oldr (* q r)) s k r))))
(defun egcd (a b)
  (egcd-iter 0 1 b 1 0 a))
(defun linear-congruence-solve (a b n)
  (destructuring-bind (d r)
      (subseq (egcd a n) 0 2)
    (if (= (mod b d) 0)
	(list (mod (/ (* r b) d) (/ n d)) (/ n d))
	nil)))

(defun incfirst (lst) (cons (+ (car lst) 1) (cdr lst)))
(defun ord (p n) 
  (if (= 0 (mod n p)) (incfirst (ord p (/ n p))) (list 0 n)))
(defun eval-pol (val coeff)
  (if (= (length coeff) 0)
      0
      (+ (* (expt val (- (length coeff) 1)) (car coeff)) (eval-pol val (cdr coeff)))))
(defun differentiate-pol (coeff)
  (if (= (length coeff) 1)
      ()
      (cons (* (- (length coeff) 1) (car coeff)) (differentiate-pol (cdr coeff)))))
(defun hensel-lift (pol approx p)
  (destructuring-bind (accuracy unit)
      (ord p (eval-pol approx pol)) ;compute quality of approximation
    (let ((h (car (linear-congruence-solve (eval-pol approx (differentiate-pol pol)) (- unit) p)))) 
      (list (+ approx (* h (expt p accuracy))) (car (ord p (eval-pol approx pol)))))))